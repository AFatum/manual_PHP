=begin
Файл для изучения Ruvy
=end
"Tony".reverse  # возвращает строку наоборот
40.to_s.reverse # здесь мы сначала перевели число 40 в строку (используя .to_s),
                # а затем перевернули эту строку наоборот (используя .reverse)

# ---------------- конвертируем данные ------------------------
20.to_s         # конвертирование числа в строку, результат - "20"
"20".to_i       # конвертирование числа в строку, результат - 20
poem.lines.to_a # конвертирование строки в массив

# ---------------- работаем с массивами ------------------------
[12, 47, 35]          # создание числового массива
[12, 47, 35].max      # возвращаем максимальное число массива
ticket = [12, 47, 35] # помещаем массив в переменную
ticket.sort           # сортируем массив по-возраствнию, получим - [12, 35, 47]
ticket.sort!          # сортирует массив данных НАВСЕГДА, 
                      # т.е. заносим новое значение в переменную

# ---------------- работаем со строками ------------------------
# http://ruby-doc.org/core-2.4.0/String.html#method-i-delete
poem['toast'] = 'honeydew'  # изменение первого слова "toast" 
                            # в строке (переменной) poem на слово "honeydew"
poem.lines.to_a.reverse     # инвертирование строк переменной poem в массиве
                            # рассмотрим подробнее:
poem.lines                  # разделяет весь текст в переменной poem на отдельные строки
poem.lines.to_a             # помещает каждую строку текста poem в отдельный элемент массива
poem.lines.to_a.reverse     # меняет местами элементы массива
# метод .join приводит результат к обычной строке
poem.lines.to_a.reverse.join # получмм текст с перевернутыми строками
poem.include? "My hand"      # метод проверяет содержание строки "My hand" в тексте poem
poem.downcase               # весь текст в нижнем регистре
poem.upcase                 # весь текст в верхнем регистре
poem.delete "My hand"       # удаляем строку "My hand" из текста poem и возвращаем копию
poem.delete "My hand"!      # тоже самое, но изменения остаются в переменной poem
                            # удаляются полностью все указанные символы, вплоть до пробелов
"hello".delete "l","lo"        #=> "heo"
"hello".delete "lo"            #=> "he"
"hello".delete "aeiou", "^e"   #=> "hell"
"hello".delete "ej-m"          #=> "ho"
# ---------------- работаем с хэшами и символами ------------------------
# создание нового хэша, хэш - это что-то типо ассоциативного массива
books = {}
books = Hash.new
books = Hash[]
# символ -  это что-то типо константы, постоянного значения, что экономит память компьютера
# присвоим к созданному хэшу символы, обозначающие оценку книги
books["Gravity's Rainbow"] = :splendid
books["Oldman and sea"] = :quite_good
books["1845 ouwrell"] = :medicore
books["JL"] = :quite_not_good
# длина хэша, возвращает количество элементов
books.lenght
# вызов значение массива по ключу
books["Gravity's Rainbow"] #=> :splendid
# возврат ключей и значений хэша
books.keys
books.values
# создание нового пустого хэша
ratings = Hash.new(0)
# присваиваем каждому значению books, свой рейтинг из массива ratings
books.values.each { |rate| ratings[rate] += 1 }
# выполнение блока в фигурных скобках 5 раз
5.times { print "Odelay!" }
# ------------- работа с папками и файлами ---------------------------
# открытие папки
Dir.entries "/" # здесь мы открываем корневую папку
# Поиск файлов по названию, либо с определённым расширением
Dir["/*.txt"]
# чтение файла comics.txt
print File.read("/comics.txt")
# копируем файл comics.txt в папку /Home с помощью метода .cp
# и заносим хендлер в переменную FileUtils
FileUtils.cp('/comics.txt', '/Home/comics.txt')
# Открытие файла в режиме добавления (редактирования) - append
File.open("/Home/comics.txt", "a") do |f|
# добавление строки в файл, через конструкцию do...end
# после слова do указываются действия, которые будут исполняться до слова end
File.open("/Home/comics.txt", "a") do |f|
  f << "Cat and Girl: http://catandgirl.com/"
end
# отображение времени и даты последнего изменения файла
File.mtime("/Home/comics.txt") #=> 2017-02-18 20:14:18 UTC
# возвращает часы/день/месяц/год, во времени последней моддификации файла
File.mtime("/Home/comics.txt").hour
File.mtime("/Home/comics.txt").day
File.mtime("/Home/comics.txt").month
File.mtime("/Home/comics.txt").year
# создание своего метода load_comics, с помощью оператора def
def load_comics(path)
  comics = {}                   # - создаём пустой ассоциативный массив
  File.foreach(path) do |line|  # - считываем файл, который передаётся в аргументе метода
    name, url = line.split(': ')# - объявляем дополнительные переменные и вносим в них данные
    comics[name] = url.strip    # - вносим данные в основной массив
  end                           # - завершаем основной foreach для наполнения массива
  comics                        # - возвращаем итоговый массив
end                             # - завершаем метод

# - загружаем (подключаем) библиотеки с методами, ф-циями
require 'popup'

#- библиотека popup содержит много разных методов, вот один из них:
#- метод .goto позволяет открыть ссылку, указанную в аргументе, в новой вкладке
Popup.goto "http://bing.com"

# - с помощью метода .make, мы формируем html-код, где h1 - это заголовок, link - это ссылка
Popup.make {
  h1 "My Links"
  link "Go to Bing", "http://bing.com"
}

# - здесь мы сформировали html-код
Popup.make do
  h1 "Things To Do"
  list do
    p "Try out Ruby"
    p "Ride a tiger"
    p "(down River Euphrates)"
  end
end

# - здесь мы формируем список ссылок из уже созданного файла comics.txt, раннее мы его положили в переменную comics = load_comics( '/comics.txt' ).
Popup.make do
  h1 "Comics on the Web"        #=> создаём заголовок 
  list do                       #=> создаём список
    comics.each do |name, url|  #=> перебираем массив данных
      link name, url            #=> формируем ссылку с данными из массива
    end
  end
end